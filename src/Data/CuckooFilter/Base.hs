{-# LANGUAGE BangPatterns #-}

module Data.CuckooFilter.Base where

import           Data.Bits
import qualified Data.Hashabler as H
import           Data.Word


type Fingerprint = Word8
type Bucket      = Word32
type Hash        = Word64
type Index       = Int

class CuckooHash c where
    buckets     :: c a -> Int

hash :: H.Hashable a => a -> Hash
hash = H.hashWord64 . H.siphash64 sipkey
    where sipkey = H.SipKey 14554470333456065145 874762856537716428 -- generated by a fair die


fingerprint :: CuckooHash c => c a -> Hash -> Fingerprint
fingerprint ch h = if f == 0 then f + 1 else f
    where f = fromIntegral $ h .&. 0xFF

indexing :: (CuckooHash c, H.Hashable a) => c a -> a -> (Fingerprint, Index, Index)
indexing mc a = (f, h1, h2)
    where !h  = hash a
          !f  = fingerprint mc h
          !h1 = priIndex mc h
          !h2 = altIndex mc f h1

priIndex :: CuckooHash c => c a -> Hash -> Index
priIndex ch h = fromIntegral (h `unsafeShiftR` 32) `mod` buckets ch

altIndex :: CuckooHash c => c a -> Fingerprint -> Index -> Index
altIndex !ch !f !i1 = fromIntegral (i1 `xor` fromIntegral f') `mod` buckets ch
    where f' :: Word32
          !f' = fromIntegral f * 0x5bd1e995

inBucket :: Fingerprint -> Bucket -> Bool
inBucket !f !b = 4 > findFingerprint f b

insertFingerprint :: Fingerprint -> Bucket -> Int -> Either (Bucket, Fingerprint) Bucket
insertFingerprint !f !b !e | bi < 4    = Right (b .|. (fif `unsafeShiftL` (8 * bi)))
                           | otherwise = Left swapped
    where !fif = fromIntegral f
          !bi  = findZero b
          swapped = let !bn = 8 * e
                        !f' =  0xFF .&. (b `unsafeShiftR` bn)
                        !b' = b .&. (complement $ 0xFF `unsafeShiftL` bn) .|. (fif `unsafeShiftL` bn)
                    in (b', fromIntegral f')

deleteFromBucket :: Fingerprint -> Bucket -> Bucket
deleteFromBucket !f !b = b .&. complement (0xFF `unsafeShiftL` (findFingerprint f b * 8))

hp2 :: Int -> Int
hp2 x = x7
    where !x0 = x - 1
          !x1 = x0 .|. (x0 `unsafeShiftR` 1)
          !x2 = x1 .|. (x1 `unsafeShiftR` 2)
          !x3 = x2 .|. (x2 `unsafeShiftR` 4)
          !x4 = x3 .|. (x3 `unsafeShiftR` 8)
          !x5 = x4 .|. (x4 `unsafeShiftR` 16)
          !x6 = x5 .|. (x5 `unsafeShiftR` 32)
          !x7 = x6 + 1

findZero :: Bucket -> Int
findZero !b = countTrailingZeros y `unsafeShiftR` 3
    where !y = (b - 0x01010101) .&. complement b .&. 0x80808080

findFingerprint :: Fingerprint -> Bucket -> Int
findFingerprint !f !b = findZero (f4 `xor` b)
    where !f2 = fromIntegral f .|. (fromIntegral f `unsafeShiftL` 8)
          !f4 = f2 .|. (f2 `unsafeShiftL` 16)

splode :: Bucket -> [Fingerprint]
splode b = [go 24, go 16, go 8, go 0]
    where go n = fromIntegral $ 0xFF .&. (b `unsafeShiftR` n)
